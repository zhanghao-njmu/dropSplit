% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dropSplit.R
\name{dropSplit}
\alias{dropSplit}
\title{Automatically identify cell-containing and empty droplets for droplet-based scRNAseq data using dropSplit.}
\usage{
dropSplit(
  counts,
  score_cutoff = 0.9,
  Gini_control = TRUE,
  Gini_threshold = 0.99,
  Uncertain_downsample = FALSE,
  Uncertain_downsample_times = 6,
  predict_Uncertain_only = TRUE,
  remove_FP_by = "dropSplitScore",
  Cell_rank = NULL,
  Uncertain_rank = NULL,
  Empty_rank = NULL,
  modelOpt = FALSE,
  xgb_params = NULL,
  xgb_nrounds = 20,
  xgb_early_stopping_rounds = 3,
  xgb_thread = 8,
  bounds = list(),
  xgb_nfold = 5,
  xgb_metric = "auc",
  opt_initPoints = length(bounds) + 1,
  opt_itersn = 10,
  opt_thread = 1,
  ...
)
}
\arguments{
\item{counts}{A \code{matrix} object or a \code{dgCMatrix} object which columns represent features and rows represent samples.}

\item{score_cutoff}{A cutoff value of \code{dropSplitScore} to determine if a droplet is cell-containing or empty. Default is 0.9, i.e. a droplet with \code{dropSplitScore}>0.9 will be classified as \code{Cell} and a with \code{dropSplitScore}<0.1  will be classified as \code{Empty}.}

\item{Gini_control}{Whether to control cell quality by CellGini. Default is \code{TRUE}.}

\item{Gini_threshold}{A value used in \code{\link{Score}} function for CellGini metric. The higher, the more conservative and will get a lower number of cells. Default is automatic.}

\item{Uncertain_downsample}{Whether to use a downsampled Uncertain droplets for predicting. Default is FALSE.}

\item{Uncertain_downsample_times}{Number of downsample times for each Uncertain droplet. \code{dropSplitScore} of downsampled droplets from the same Uncertain droplet will be averaged. Default is 6.}

\item{predict_Uncertain_only}{Whether to predict only the Uncertain droplets. Default is \code{TRUE}.}

\item{remove_FP_by}{metric used to remove the estimated false positives by. Must be one of \code{nCount}, \code{nFeature}, \code{CellEntropy}, \code{CellEfficiency}, \code{dropSplitScore}. Default is \code{dropSplitScore}.}

\item{Cell_rank, Uncertain_rank, Empty_rank}{Custom Rank value to mark the droplets as Cell, Uncertain and Empty labels for the data to be trained. Default is automatic. But useful when the default value is considered to be wrong from the RankMSE plot.}

\item{modelOpt}{Whether to optimize the model using \code{\link{xgbOptimization}}. Will take long time for large datasets. If \code{TRUE}, will overwrite the parameters list in \code{xgb_params}.}

\item{xgb_params}{The \code{list} of XGBoost parameters.}

\item{xgb_nrounds}{Max number of boosting iterations.}

\item{xgb_early_stopping_rounds}{If NULL, the early stopping function is not triggered. If set to an integer k, training with a validation set will stop if the performance doesn't improve for k rounds. Setting this parameter engages the \code{cb.early.stop} callback.}

\item{xgb_thread}{Number of thread used in \code{\link[xgboost]{xgb.cv}}.}

\item{bounds}{A named list of lower and upper bounds for \code{params} in \code{\link[xgboost]{xgb.cv}}. The names of the list should be arguments passed to xgb.cv Use "L" suffix to indicate integers. A fixed parameter should be a two-length vector with the same value, i.e. bound=list(lambda = c(5, 5))}

\item{xgb_nfold}{The original dataset is randomly partitioned into nfold equal size subsamples.}

\item{xgb_metric}{A evaluation metric to be used in cross validation and will to be maximized. Possible options are:
\itemize{
\item \code{auc} Area under curve
\item \code{aucpr} Area under PR curve
}}

\item{opt_initPoints}{Number of points to initialize the process with. Points are chosen with latin hypercube sampling within the bounds supplied.}

\item{opt_itersn}{The total number of times \code{xgb.cv} will be run after initialization.}

\item{opt_thread}{Number of thread used in \code{\link[ParBayesianOptimization]{bayesOpt}}.}

\item{...}{Other arguments passed to \code{\link{xgbOptimization}}.}
}
\value{
A list of seven objects:
\describe{
\item{meta_info}{A \code{DataFrame} object of evaluation metrics to be used in dropSplit and the final droplet classification.}
\item{train}{The dataset trained in the XGBoost model. It consists of two pre-defined droplets: Cell(real-world + simulated) and Empty.}
\item{train_label}{Labels for the \code{train}. 0 represents 'Empty', 1 represents 'Cell'.}
\item{to_predict}{The dataset that to be predicted. It consists of all three pre-defined droplets: Cell, Uncertain and Empty.}
\item{model}{The XGBoost model used in dropSplit for classification.}
\item{importance_matrix}{A \code{data.frame} of feature importances in the classification model.}
\item{tree}{The trees from the classification model.}
}
}
\description{
dropSplit is designed to identify true cells from droplet-based scRNAseq data.
It consists of three parts: quality control, model construction and droplet classification, summarizing features.
dropSplit provides some special droplet QC metrics such as CellEntropy or CellGini which can help identification.
In general, user can use the predefined parameters in the XGBoost and get the important features that help in cell identification.
It also provides a automatic XGBoost hyperparameters-tuning function to optimize the model.
}
\examples{
# Simulate a counts matrix including 20000 empty droplets, 2000 large cells and 200 small cells.
counts <- simCounts(nempty = 20000, nlarge = 2000, nsmall = 200)
counts_label <- gsub(pattern = "-.*", replacement = "", x = colnames(counts), perl = TRUE)
result <- dropSplit(counts)
head(result$meta_info)

dropSplitClass <- result$meta_info$dropSplitClass
# True positive
sum(counts_label \%in\% c("LargeCell", "SmallCell") & dropSplitClass == "Cell")
# False negative
sum(counts_label \%in\% c("LargeCell", "SmallCell") & dropSplitClass != "Cell")
# True negative
sum(counts_label == "Empty" & dropSplitClass != "Cell")
# False positive
sum(counts_label == "Empty" & dropSplitClass == "Cell")
}
